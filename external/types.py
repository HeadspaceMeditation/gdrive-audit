from collections import namedtuple
from itertools import zip_longest


class NamedTupleFactory(object):
    """
    NamedTupleFactory allows compact data type declarations with a simple api
    that allows encoding and decoding data off the wire into python data types.
    As its name suggest, a factory will convert data to and from named tuples.
    see `collections.namedtuple`
    Observes the basic namedtuple api for factory instantiation,
    but allows instantiation from an input dictionary or *args,
    and allows the specification of encoders and decoders to facilitate nested encoders and
    specialized data type conversions e.g string to date, date to string.
    """
    def __init__(self, type_name, field_names, encoders=None, decoders=None, require_all_fields=False):
        """
        :param type_name: Name of type to be generated by the factory.
        :param field_names: allowed fields.
        :param encoders: dictionary of field names to functions which, return a json serializable value
                         the function accepts the original value and returns the json serializable value.
        :param decoders: dictionary of field names to functions which decode the corresponding json serializable value.
                         the function accepts the json deserialized value and returns the original value.
        """
        self.type_name = type_name
        self.require_all_fields = require_all_fields
        self.fields = field_names
        self.encoders = {}
        self.decoders = {}
        self.nested_coders = {}
        field_names = set(field_names)

        if encoders and isinstance(encoders, dict):
            for k, v in encoders.items():
                if k not in field_names:
                    continue
                if not callable(v):
                    continue
                self.encoders[k] = v
                if isinstance(v, NamedTupleFactory):
                    self.nested_coders[k] = v

        self.decoders = dict(self.nested_coders)

        if decoders and isinstance(decoders, dict):
            for k, v in decoders.items():
                if k not in field_names:
                    continue
                if not callable(v):
                    continue
                self.decoders[k] = v
                if k not in self.nested_coders and isinstance(v, NamedTupleFactory):
                    self.encoders[k] = v
                    self.nested_coders[k] = v

        self.data_type = namedtuple(type_name, self.fields)

    def _is_list_of_objects(self, input):
        # Is the input a list of item instantiation parameters?
        if not input:
            return False
        if not isinstance(input, (list, tuple)):
            return False
        # If item list is same length as field list then we have to check all items
        # to disambiguate between an object list and an arg list, otherwise we can just check the first item.
        items = input if len(self.fields) == len(input) else input[:1]
        for item in items:
            if not self._is_valid_dict(item) and not self._is_valid_arg_list(item):
                return False
        return True

    def _is_valid_arg_list(self, obj):
        # Is the obj a valid argument list for single object instantiation?
        # Note: _is_list_of_objects must always be checked prior to this in order
        #       to effectively disambiguate object lists and arg lists.
        if not obj:
            return False
        if not isinstance(obj, (list, tuple)):
            return False
        return len(obj) == len(self.fields)

    def _is_valid_dict(self, obj):
        # Is object a dict containing required keys?
        if not isinstance(obj, dict):
            return False
        if self.require_all_fields:
            return len(set(self.fields) - set(obj.keys())) == 0
        return True

    def updated(self, obj, **kwargs):
        """ Return a new object with updated fields specified in keyword args. """
        if not self.is_native_type(obj):
            raise ValueError("Unexpected object type.")
        data = obj._asdict()
        data.update(kwargs)
        return self(data)

    def __call__(self, *args, **kwargs):
        """
        Returns a typed object or a list of typed objects.

        Allowed inputs types:
        - List of dictionaries -> array of objects
        - List of lists of field values -> array of objects
        - List of field values -> object
        - Dictionary -> object
        - *args corresponding to field values -> object
        - **kwargs corresponding to field names and values -> object
        """
        if len(args) == 1 and isinstance(args[0], dict):
            data = args[0]
            init_args = {f: data.get(f) for f in self.fields}
            if self.nested_coders:
                init_args = {k: self.nested_coders[k](v) if k in self.nested_coders and v else v
                             for k, v in init_args.items()}
            return self.data_type(**init_args)

        if len(args) == 1 and self._is_list_of_objects(args[0]):
            # Iterate and recursively initialize.
            return [self(item) for item in args[0]]

        if len(args) == 1 and self._is_valid_arg_list(args[0]):
            args = args[0]

        # Convert to dict and recurse.
        init_dict = {}
        if args:
            init_dict = dict(zip_longest(self.fields, args))
        if kwargs:
            init_dict.update(kwargs)
        return self(init_dict)

    def is_native_type(self, obj):
        return obj.__class__.__name__ == self.type_name

    def to_python(self, obj):
        """
        Prepares values for json serialization for the keys specified by the factory's encoders dictionary.
        :param obj: can be a named tuple generated by this factory or a dictionary.
        :return: namedtuple which is ready to json serialize.
        """

        if not self.is_native_type(obj):
            if self._is_valid_dict(obj):
                obj = self(obj)
            elif self._is_list_of_objects(obj):
                return [self.to_python(item) for item in obj]
            elif self._is_valid_arg_list(obj):
                obj = self(*obj)
            elif obj in ([], (), None):
                return obj
            else:
                raise TypeError("Object cannot be parsed.")

        if not self.encoders:
            return obj

        mutable = obj._asdict()
        for field, encoder in self.encoders.items():
            value = mutable[field]
            if value is None:
                continue
            if isinstance(encoder, NamedTupleFactory):
                mutable[field] = encoder.to_python(value)
            else:
                mutable[field] = encoder(value)
        return self(mutable)

    def from_python(self, obj):
        """
        Converts json safe values for the keys specified by the factory's decoders dictionary.
        :param obj: can be a named tuple generated by this factory or a dictionary.
        :return: namedtuple which is ready to json serialize.
        """

        if not self.is_native_type(obj):
            if self._is_valid_dict(obj):
                obj = self(obj)
            elif self._is_list_of_objects(obj):
                return [self.from_python(item) for item in obj]
            elif self._is_valid_arg_list(obj):
                obj = self(*obj)
            elif obj in ([], (), None):
                return obj
            else:
                raise TypeError("Object cannot be parsed.")

        if not self.decoders:
            return obj

        mutable = obj._asdict()
        for field, decoder in self.decoders.items():
            value = mutable[field]
            if value is None:
                continue
            if isinstance(decoder, NamedTupleFactory):
                mutable[field] = decoder.from_python(value)
            else:
                mutable[field] = decoder(value)
        return self(mutable)
